package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"bytes"
	"context"
	"filevault/graph/model"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"github.com/99designs/gqlgen/graphql"
	pgx "github.com/jackc/pgx/v5"
	storage_go "github.com/supabase-community/storage-go"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, name string, email string, password string) (*model.User, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	var id int
	err = r.DB.Conn.QueryRow(ctx,
		"INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING id",
		name, email, string(hashedPassword),
	).Scan(&id)
	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:       fmt.Sprintf("%d", id),
		Name:     &name,
		Email:    email,
		Password: string(hashedPassword),
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	cmdTag, err := r.DB.Conn.Exec(ctx, "DELETE FROM users WHERE id=$1", id)
	if err != nil {
		return false, err
	}
	if cmdTag.RowsAffected() == 0 {
		return false, fmt.Errorf("no user found with id %s", id)
	}
	return true, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var u model.User
	err := r.DB.Conn.QueryRow(ctx, "SELECT id, name, email, password FROM users WHERE email=$1", email).
		Scan(&u.ID, &u.Name, &u.Email, &u.Password)
	if err != nil {
		return nil, fmt.Errorf("no user found with email %s", email)
	}

	if err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password)); err != nil {
		return nil, fmt.Errorf("invalid password")
	}

	token, err := generateJWT(u.ID)
	if err != nil {
		return nil, err
	}

	u.Password = ""

	return &model.AuthPayload{
		User:  &u,
		Token: token,
	}, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, userID string, file graphql.Upload) (*model.File, error) {
	fmt.Printf("UploadFile called with userID: %s, filename: %s\n", userID, file.Filename)

	authenticatedUserID, authenticated := GetUserIDFromCtx(ctx)
	if !authenticated {
		fmt.Println("Authentication failed - no user in context")
		return nil, fmt.Errorf("authentication required")
	}

	fmt.Printf("Authenticated user: %s, requested userID: %s\n", authenticatedUserID, userID)

	if authenticatedUserID != userID {
		fmt.Printf("Authorization failed - user %s cannot upload for user %s\n", authenticatedUserID, userID)
		return nil, fmt.Errorf("unauthorized: can only upload files for your own account")
	}

	fmt.Printf("Reading file content, size: %d bytes\n", file.Size)
	data := make([]byte, file.Size)
	_, err := file.File.Read(data)
	if err != nil {
		fmt.Printf("Error reading file: %v\n", err)
		return nil, err
	}

	bucket := "filevault"
	path := fmt.Sprintf("user_%s/%s", userID, file.Filename)
	fmt.Printf("Uploading to Supabase: bucket=%s, path=%s\n", bucket, path)

	fmt.Printf("Checking/creating bucket: %s\n", bucket)
	_, bucketErr := SupabaseClient.CreateBucket(bucket, storage_go.BucketOptions{
		Public: true,
	})
	if bucketErr != nil {
		fmt.Printf("Bucket creation result (may already exist): %v\n", bucketErr)
	}

	fmt.Printf("About to call SupabaseClient.UploadFile with bucket=%s, path=%s, data_size=%d\n", bucket, path, len(data))

	fmt.Printf("Trying direct HTTP upload to Supabase REST API...\n")

	supabaseURL := os.Getenv("SUPABASE_URL")
	serviceKey := os.Getenv("SUPABASE_SERVICE_ROLE_KEY")

	if supabaseURL == "" || serviceKey == "" {
		return nil, fmt.Errorf("missing Supabase configuration")
	}

	uploadURL := fmt.Sprintf("%s/storage/v1/object/%s/%s", supabaseURL, bucket, path)
	fmt.Printf("Upload URL: %s\n", uploadURL)

	req, err := http.NewRequest("POST", uploadURL, bytes.NewReader(data))
	if err != nil {
		return nil, fmt.Errorf("failed to create HTTP request: %v", err)
	}

	req.Header.Set("Authorization", "Bearer "+serviceKey)
	req.Header.Set("Content-Type", "application/octet-stream")
	req.Header.Set("Content-Length", fmt.Sprintf("%d", len(data)))

	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("HTTP request failed: %v", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	fmt.Printf("HTTP Response Status: %s\n", resp.Status)
	fmt.Printf("HTTP Response Body: %s\n", string(respBody))

	if resp.StatusCode != 200 && resp.StatusCode != 201 {
		return nil, fmt.Errorf("Supabase upload failed with status %d: %s", resp.StatusCode, string(respBody))
	}

	fmt.Printf("Direct HTTP upload successful!\n")

	fmt.Printf("Storing file record in database: userID=%s, filename=%s, path=%s, size=%d\n", userID, file.Filename, path, len(data))
	var id int
	var uploadedAt time.Time
	err = r.DB.Conn.QueryRow(ctx,
		"INSERT INTO files (user_id, filename, path, uploaded_at, size) VALUES ($1, $2, $3, NOW(), $4) RETURNING id, uploaded_at",
		userID, file.Filename, path, len(data),
	).Scan(&id, &uploadedAt)
	if err != nil {
		fmt.Printf("Database insert error: %v\n", err)
		return nil, err
	}
	fmt.Printf("Database insert successful, file ID: %d, uploaded at: %v, size: %d bytes\n", id, uploadedAt, len(data))

	downloadUrl := fmt.Sprintf("%s/storage/v1/object/public/%s/%s",
		os.Getenv("SUPABASE_URL"), bucket, path)

	fmt.Printf("Upload completed successfully, returning file object with ID: %d\n", id)
	return &model.File{
		ID:           fmt.Sprintf("%d", id),
		Filename:     file.Filename,
		Path:         path,
		UploadedAt:   uploadedAt.Format(time.RFC3339),
		DownloadFile: downloadUrl,
		Size:         int32(len(data)),
	}, nil
}

func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	userID, authenticated := GetUserIDFromCtx(ctx)
	if !authenticated {
		return false, fmt.Errorf("authentication required")
	}

	var filename, path, fileUserID string
	err := r.DB.Conn.QueryRow(ctx,
		"SELECT filename, path, user_id FROM files WHERE id = $1",
		fileID,
	).Scan(&filename, &path, &fileUserID)

	if err != nil {
		if err == pgx.ErrNoRows {
			return false, fmt.Errorf("file not found")
		}
		return false, err
	}

	if fileUserID != userID {
		return false, fmt.Errorf("unauthorized: you can only delete your own files")
	}

	supabaseURL := os.Getenv("SUPABASE_URL")
	serviceRoleKey := os.Getenv("SUPABASE_SERVICE_ROLE_KEY")

	if supabaseURL == "" || serviceRoleKey == "" {
		return false, fmt.Errorf("supabase configuration missing")
	}

	deleteURL := fmt.Sprintf("%s/storage/v1/object/filevault/%s", supabaseURL, path)
	fmt.Printf("Attempting to delete file from storage: %s\n", deleteURL)

	req, err := http.NewRequest("DELETE", deleteURL, nil)
	if err != nil {
		return false, err
	}

	req.Header.Set("Authorization", "Bearer "+serviceRoleKey)
	req.Header.Set("apikey", serviceRoleKey)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return false, fmt.Errorf("failed to delete file from storage: %v", err)
	}
	defer resp.Body.Close()

	fmt.Printf("Storage deletion response status: %d\n", resp.StatusCode)

	if resp.StatusCode != 200 && resp.StatusCode != 404 {
		respBody, _ := io.ReadAll(resp.Body)
		fmt.Printf("Storage deletion failed with response: %s\n", string(respBody))
		return false, fmt.Errorf("storage deletion failed with status %d: %s", resp.StatusCode, string(respBody))
	}

	result, err := r.DB.Conn.Exec(ctx,
		"DELETE FROM files WHERE id = $1 AND user_id = $2",
		fileID, userID,
	)
	if err != nil {
		return false, err
	}

	rowsAffected := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("file not found or not authorized")
	}

	fmt.Printf("Successfully deleted file: %s (ID: %s) for user: %s\n", filename, fileID, userID)
	return true, nil
}

func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	userID, authenticated := GetUserIDFromCtx(ctx)
	if !authenticated {
		return nil, fmt.Errorf("authentication required")
	}

	fmt.Printf("Authenticated user %s is requesting users list\n", userID)

	rows, err := r.DB.Conn.Query(ctx, "SELECT id, name, email FROM users")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var users []*model.User
	for rows.Next() {
		var u model.User
		if err := rows.Scan(&u.ID, &u.Name, &u.Email); err != nil {
			return nil, err
		}
		users = append(users, &u)
	}
	return users, nil
}

func (r *queryResolver) UserFiles(ctx context.Context, userID string) ([]*model.File, error) {

	authUserID, authenticated := GetUserIDFromCtx(ctx)
	if !authenticated {
		return nil, fmt.Errorf("authentication required")
	}

	if authUserID != userID {
		return nil, fmt.Errorf("unauthorized: can only access your own files")
	}

	rows, err := r.DB.Conn.Query(ctx,
		"SELECT id, filename, path, uploaded_at, COALESCE(size, 0) FROM files WHERE user_id=$1 ORDER BY uploaded_at DESC", userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var files []*model.File
	bucket := "filevault"
	baseURL := os.Getenv("SUPABASE_URL")

	for rows.Next() {
		var f model.File
		var uploadedAt time.Time
		var size int32
		if err := rows.Scan(&f.ID, &f.Filename, &f.Path, &uploadedAt, &size); err != nil {
			return nil, err
		}
		f.UploadedAt = uploadedAt.Format(time.RFC3339)
		f.Size = size
		f.DownloadFile = fmt.Sprintf("%s/storage/v1/object/public/%s/%s", baseURL, bucket, f.Path)
		files = append(files, &f)
	}

	fmt.Printf("Retrieved %d files for user %s\n", len(files), userID)
	return files, nil
}

func (r *queryResolver) DownloadFile(ctx context.Context, fileID string) (*model.File, error) {
	userID, authenticated := GetUserIDFromCtx(ctx)
	if !authenticated {
		return nil, fmt.Errorf("authentication required")
	}

	// Query file and verify ownership
	var file model.File
	var uploadedAt time.Time
	var fileUserID string
	var size int32
	err := r.DB.Conn.QueryRow(ctx,
		"SELECT id, filename, path, uploaded_at, user_id, COALESCE(size, 0) FROM files WHERE id = $1",
		fileID,
	).Scan(&file.ID, &file.Filename, &file.Path, &uploadedAt, &fileUserID, &size)

	if err != nil {
		if err == pgx.ErrNoRows {
			return nil, fmt.Errorf("file not found")
		}
		return nil, err
	}

	if fileUserID != userID {
		return nil, fmt.Errorf("unauthorized: you can only download your own files")
	}

	file.UploadedAt = uploadedAt.Format(time.RFC3339)
	file.Size = size
	file.DownloadFile = fmt.Sprintf("%s/storage/v1/object/public/filevault/%s",
		os.Getenv("SUPABASE_URL"), file.Path)

	return &file, nil
}

func (r *queryResolver) UserStorageInfo(ctx context.Context, userID string) (*model.StorageInfo, error) {

	authUserID, authenticated := GetUserIDFromCtx(ctx)
	if !authenticated {
		return nil, fmt.Errorf("authentication required")
	}

	if authUserID != userID {
		return nil, fmt.Errorf("unauthorized: can only access your own storage info")
	}

	var totalFiles int32
	var totalSize int64
	err := r.DB.Conn.QueryRow(ctx,
		"SELECT COUNT(*), COALESCE(SUM(size), 0) FROM files WHERE user_id = $1",
		userID,
	).Scan(&totalFiles, &totalSize)

	if err != nil {
		return nil, err
	}

	const unit = 1024
	var formattedSize string
	if totalSize < unit {
		formattedSize = fmt.Sprintf("%d B", totalSize)
	} else {
		div, exp := int64(unit), 0
		for n := totalSize / unit; n >= unit; n /= unit {
			div *= unit
			exp++
		}
		formattedSize = fmt.Sprintf("%.1f %cB", float64(totalSize)/float64(div), "KMGTPE"[exp])
	}

	return &model.StorageInfo{
		TotalFiles:    totalFiles,
		TotalSize:     int32(totalSize),
		FormattedSize: formattedSize,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
